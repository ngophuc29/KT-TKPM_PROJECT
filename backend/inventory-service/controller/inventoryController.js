require("dotenv").config();

const Inventory = require("../models/InventoryModels");
const axios = require("axios");
const { callApiWithRetry } = require("../utils/apiRetry");

// URL c·ªßa Product Service (ƒë·ªïi n·∫øu c·∫ßn)
const PRODUCT_SERVICE_URL = process.env.PRODUCT_SERVICE_URL || "http://localhost:3000/api/products/products";
const PRODUCT_SERVICE_URLImport = process.env.PRODUCT_SERVICE_URLImport || "http://localhost:3000/api/products/product";
const PRODUCT_UPDATE_STOCK_URL = process.env.PRODUCT_UPDATE_STOCK_URL || "http://localhost:3000/api/products/update-stock";
const CART_API_URL = process.env.CART_API_URL || "http://localhost:3000/api/cart";
const Order_api = process.env.ORDER_API || 'http://localhost:3000/api/orders'
const LOW_STOCK_THRESHOLD = 5; // Ng∆∞·ª°ng c·∫£nh b√°o t·ªìn kho th·∫•p

// ------------------------------
// H√†m helper d√πng ƒë·ªÉ l·∫•y d·ªØ li·ªáu s·∫£n ph·∫©m t·ª´ Product Service
// ------------------------------
const fetchProductsData = async () => {
    const response = await callApiWithRetry({
        method: 'get',
        url: PRODUCT_SERVICE_URL
    });
    const products = response.data.data;
    if (!Array.isArray(products)) {
        throw new Error("D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá t·ª´ Product Service");
    }
    return products;
};

// ------------------------------
// 1Ô∏è‚É£ API l·∫•y to√†n b·ªô s·∫£n ph·∫©m t·ª´ Product Service (ƒë·ªÉ ki·ªÉm tra stock)
// ------------------------------
exports.getAllProducts = async (req, res) => {
    try {
        const products = await fetchProductsData();
        res.json(products);
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y danh s√°ch s·∫£n ph·∫©m",
            error: error.message,
        });
    }
};

// ------------------------------
// 2Ô∏è‚É£ API l·∫•y danh s√°ch t·ªìn kho t·ª´ Inventory Model
// ------------------------------
exports.getInventory = async (req, res) => {
    try {
        // ∆Øu ti√™n l·∫•y d·ªØ li·ªáu t·ª´ Inventory Model
        const inventoryData = await Inventory.find({});
        if (!inventoryData || inventoryData.length === 0) {
            return res.status(404).json({ message: "Kh√¥ng c√≥ d·ªØ li·ªáu t·ªìn kho trong Inventory" });
        }
        const result = inventoryData.map(item => ({
            productId: item.productId,
            name: item.name,
            stock: item.quantity,
            lowStock: item.quantity <= LOW_STOCK_THRESHOLD
        }));
        res.json(result);
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y t·ªìn kho t·ª´ Inventory Model",
            error: error.message,
        });
    }
};

// ------------------------------
// 3Ô∏è‚É£ API l·∫•y stock theo danh s√°ch productId
//     Fallback: n·∫øu l·ªói, l·∫•y d·ªØ li·ªáu t·ª´ Inventory Model
// ------------------------------
exports.getStockByProductIds = async (req, res) => {
    try {
        // L·∫•y productIds t·ª´ params v√† chuy·ªÉn th√†nh m·∫£ng
        const { productIds } = req.params;
        const productIdsArray = productIds ? productIds.split(',') : [];
        if (!Array.isArray(productIdsArray) || productIdsArray.length === 0) {
            return res.status(400).json({ message: "Danh s√°ch productIds kh√¥ng h·ª£p l·ªá" });
        }
        const products = await fetchProductsData();
        const filtered = products.filter((product) =>
            productIdsArray.includes(product._id)
        );
        res.json(filtered.map((p) => ({ productId: p._id, stock: p.stock })));
    } catch (error) {
        console.error("L·ªói khi l·∫•y t·ªìn kho theo danh s√°ch t·ª´ Product Service:", error.message);
        // Fallback: l·∫•y t·ª´ Inventory Model
        try {
            const productIdsArray = req.params.productIds ? req.params.productIds.split(',') : [];
            const inventoryData = await Inventory.find({
                productId: { $in: productIdsArray },
            });
            res.json(inventoryData.map((item) => ({
                productId: item.productId,
                stock: item.quantity,
            })));
        } catch (fallbackError) {
            res.status(500).json({
                message: "L·ªói khi l·∫•y t·ªìn kho theo danh s√°ch t·ª´ Inventory Model",
                error: fallbackError.message,
            });
        }
    }
};

// ------------------------------
// 4Ô∏è‚É£ API ki·ªÉm tra s·∫£n ph·∫©m c√≤n h√†ng kh√¥ng (ch·ªâ d√πng Inventory Model)
// ------------------------------
exports.getProductStock = async (req, res) => {
    try {
        const inventoryData = await Inventory.findOne({ productId: req.params.productId });
        if (!inventoryData) {
            return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i trong Inventory Model" });
        }
        res.json({ inStock: inventoryData.quantity > 0, stockInInventory: inventoryData.quantity });
    } catch (fallbackError) {
        res.status(500).json({
            message: "L·ªói khi ki·ªÉm tra t·ªìn kho t·ª´ Inventory Model",
            error: fallbackError.message,
        });
    }
};

// ------------------------------
// 5Ô∏è‚É£ API th·ªëng k√™ t·ªïng s·ªë l∆∞·ª£ng h√†ng t·ªìn kho t·ª´ Product Service
//     Fallback: n·∫øu l·ªói, t√≠nh t·ª´ d·ªØ li·ªáu trong Inventory Model
// ------------------------------
exports.getStockStats = async (req, res) => {
    try {
        const products = await fetchProductsData();
        const totalStock = products.reduce((sum, product) => sum + product.stock, 0);
        res.json({ totalStock });
    } catch (error) {
        console.error("L·ªói khi th·ªëng k√™ t·ªìn kho t·ª´ Product Service:", error.message);
        // Fallback: t√≠nh t·ªïng t·ª´ Inventory Model
        try {
            const inventoryData = await Inventory.find({});
            const totalStock = inventoryData.reduce((sum, item) => sum + item.quantity, 0);
            res.json({ totalStock });
        } catch (fallbackError) {
            res.status(500).json({
                message: "L·ªói khi th·ªëng k√™ t·ªìn kho t·ª´ Inventory Model",
                error: fallbackError.message,
            });
        }
    }
};

// ------------------------------
// 6Ô∏è‚É£ API nh·∫≠p h√†ng - tƒÉng stock trong Product Service
//      Sau khi c·∫≠p nh·∫≠t Product Service, c·∫≠p nh·∫≠t lu√¥n Inventory Model ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
// ------------------------------
exports.importStock = async (req, res) => {
    try {
        const { productId, quantity } = req.params;
        const qty = Number(quantity);
        if (!productId || qty <= 0) {
            return res.status(400).json({ message: "‚ùå D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá" });
        }
        console.log("üìå Nh·∫≠p h√†ng cho Product ID:", productId);

        // L·∫•y th√¥ng tin s·∫£n ph·∫©m t·ª´ Product Service
        const productResponse = await axios.get(`${PRODUCT_SERVICE_URLImport}/${productId}`);
        console.log("üîç D·ªØ li·ªáu s·∫£n ph·∫©m nh·∫≠n ƒë∆∞·ª£c:", productResponse.data);
        const product = productResponse.data;
        if (!product || product.stock == null) {
            return res.status(404).json({ message: "‚ùå S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i ho·∫∑c thi·∫øu stock" });
        }
        if (typeof product.stock !== "number") {
            console.error("üö® L·ªói: stock kh√¥ng ph·∫£i l√† s·ªë", product);
            return res.status(500).json({ message: "‚ùå stock kh√¥ng h·ª£p l·ªá", stockType: typeof product.stock });
        }

        // TƒÉng stock
        const newStock = product.stock + qty;
        console.log("üìå Stock m·ªõi:", newStock);

        // C·∫≠p nh·∫≠t stock trong Product Service
        const updateResponse = await axios.put(`${PRODUCT_SERVICE_URLImport}/${productId}`, { stock: newStock });
        console.log("üîÑ K·∫øt qu·∫£ c·∫≠p nh·∫≠t:", updateResponse.data);
        if (!updateResponse.data.data || updateResponse.data.data.stock == null) {
            return res.status(500).json({ message: "‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t stock" });
        }

        // C·∫≠p nh·∫≠t lu√¥n Inventory Model sau khi Product Service ƒë∆∞·ª£c c·∫≠p nh·∫≠t
        await Inventory.findOneAndUpdate(
            { productId: productId, name: product.name },
            { quantity: updateResponse.data.data.stock, updatedAt: new Date() },
            { upsert: true, new: true }
        );

        res.status(200).json({
            message: "‚úÖ Nh·∫≠p h√†ng th√†nh c√¥ng!",
            newStock: updateResponse.data.data.stock,
        });
    } catch (error) {
        console.error("üö® L·ªói nh·∫≠p h√†ng:", error.response?.data || error.message);
        res.status(500).json({
            message: "‚ùå L·ªói server khi nh·∫≠p h√†ng",
            error: error.message,
        });
    }
};

// ------------------------------
// 7Ô∏è‚É£ API ƒë·ªìng b·ªô Inventory v·ªõi Product Service
// ------------------------------
exports.syncInventory = async (req, res) => {
    try {
        console.log("üîÑ ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu t·ª´ Product Service...");
        const products = await fetchProductsData();
        await Promise.all(
            products.map((product) =>
                Inventory.findOneAndUpdate(
                    { productId: product._id, name: product.name },
                    { quantity: product.stock, updatedAt: new Date() },
                    { upsert: true, new: true }
                )
            )
        );
        console.log("‚úÖ ƒê·ªìng b·ªô d·ªØ li·ªáu th√†nh c√¥ng!");
        res.json({ message: "ƒê·ªìng b·ªô d·ªØ li·ªáu th√†nh c√¥ng!" });
    } catch (error) {
        console.error("üö® L·ªói khi ƒë·ªìng b·ªô Inventory:", error.message);
        res.status(500).json({
            message: "L·ªói server khi ƒë·ªìng b·ªô Inventory",
            error: error.message,
        });
    }
};

// ------------------------------
// 8Ô∏è‚É£ API x√°c nh·∫≠n ƒë∆°n h√†ng
//     Sau khi x√°c nh·∫≠n, gi·∫£m s·ªë l∆∞·ª£ng t·ªìn trong Inventory v√† c·∫≠p nh·∫≠t stock cho Product Service
// ------------------------------
exports.confirmOrder = async (req, res) => {
    try {
        // Gi·∫£ s·ª≠ items ƒë∆∞·ª£c truy·ªÅn d∆∞·ªõi d·∫°ng chu·ªói JSON trong req.params.items
        const items = JSON.parse(req.params.items);
        if (!items || !Array.isArray(items) || items.length === 0) {
            return res.status(400).json({ message: "Kh√¥ng c√≥ m·∫∑t h√†ng ƒë·ªÉ x√°c nh·∫≠n" });
        }

        await Promise.all(
            items.map(async (item) => {
                // C·∫≠p nh·∫≠t Inventory: tr·ª´ quantity (kh√¥ng c√≤n reserved)
                const updated = await Inventory.findOneAndUpdate(
                    { productId: item.productId },
                    {
                        $inc: { quantity: -item.quantity },
                        $set: { updatedAt: new Date() }
                    },
                    { new: true }
                );
                if (!updated) {
                    throw new Error(`S·∫£n ph·∫©m ${item.productId} kh√¥ng t·ªìn t·∫°i`);
                }
                if (updated.quantity < 0) {
                    throw new Error(`Kh√¥ng ƒë·ªß h√†ng cho s·∫£n ph·∫©m ${item.productId} sau khi x√°c nh·∫≠n`);
                }
                // C·∫≠p nh·∫≠t l·∫°i stock trong Product Service th√¥ng qua endpoint updateStock
                await axios.put(`${PRODUCT_UPDATE_STOCK_URL}/${item.productId}/${updated.quantity}`, null, { timeout: 5000 });
            })
        );
        res.json({ success: true });
    } catch (error) {
        res.status(500).json({ message: "L·ªói khi x√°c nh·∫≠n ƒë∆°n h√†ng trong Inventory", error: error.message });
    }
};

// ------------------------------
// 9Ô∏è‚É£ API restore stock: c·ªông th√™m s·ªë l∆∞·ª£ng v√†o t·ªìn kho (tham s·ªë qua params: productId v√† quantity)
// ------------------------------
exports.restoreStock = async (req, res) => {
    try {
        const { productId, quantity } = req.params;
        const qty = Number(quantity);
        if (!productId || !qty || qty <= 0) {
            return res.status(400).json({ message: "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá" });
        }
        const inventory = await Inventory.findOne({ productId });
        if (!inventory) {
            return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i" });
        }
        // Restore: c·ªông th√™m s·ªë l∆∞·ª£ng v√†o t·ªìn kho
        inventory.quantity += qty;
        inventory.updatedAt = new Date();
        await inventory.save();
        res.json({ success: true, quantity: inventory.quantity });
    } catch (error) {
        res.status(500).json({ message: "L·ªói khi restore s·∫£n ph·∫©m", error: error.message });
    }
};

// ------------------------------
// 10Ô∏è‚É£ API l·∫•y th√¥ng tin s·∫£n ph·∫©m trong Inventory
// ------------------------------
exports.getProduct = async (req, res) => {
    try {
        const { productId } = req.params;
        const item = await Inventory.findOne({ productId });
        if (!item) return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i" });
        res.json({
            productId: item.productId,
            quantity: item.quantity,
            name: item.name,
        });
    } catch (error) {
        res.status(500).json({ message: "L·ªói khi l·∫•y th√¥ng tin t·ªìn kho", error: error.message });
    }
};

// ------------------------------
// 11Ô∏è‚É£ API th·ªëng k√™ t·ªïng quan
// ------------------------------
exports.getGeneralStats = async (req, res) => {
    try {
        // L·∫•y th√¥ng tin t·ª´ c√°c service
        const [products, orders, inventory] = await Promise.all([
            axios.get(PRODUCT_SERVICE_URL),
            axios.get(Order_api),
            Inventory.find({})
        ]);

        // T√≠nh to√°n th·ªëng k√™
        const totalProducts = products.data.data.length;
        const totalOrders = orders.data.length;
        const totalInventory = inventory.reduce((sum, item) => sum + item.quantity, 0);
        const totalRevenue = orders.data.reduce((sum, order) => sum + order.finalTotal, 0);

        // Th·ªëng k√™ theo tr·∫°ng th√°i ƒë∆°n h√†ng
        const orderStatusStats = orders.data.reduce((acc, order) => {
            acc[order.status] = (acc[order.status] || 0) + 1;
            return acc;
        }, {});

        // Th·ªëng k√™ s·∫£n ph·∫©m theo danh m·ª•c
        const categoryStats = products.data.data.reduce((acc, product) => {
            acc[product.category] = (acc[product.category] || 0) + 1;
            return acc;
        }, {});

        // Th·ªëng k√™ s·∫£n ph·∫©m t·ªìn kho th·∫•p
        const lowStockProducts = inventory.filter(item => item.quantity <= LOW_STOCK_THRESHOLD);

        res.json({
            general: {
                totalProducts,
                totalOrders,
                totalInventory,
                totalRevenue,
                averageOrderValue: totalOrders > 0 ? totalRevenue / totalOrders : 0
            },
            orderStatus: orderStatusStats,
            categoryStats,
            inventoryAlerts: {
                lowStockCount: lowStockProducts.length,
                lowStockProducts: lowStockProducts.map(item => ({
                    productId: item.productId,
                    name: item.name,
                    currentStock: item.quantity
                }))
            }
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ t·ªïng quan",
            error: error.message
        });
    }
};

// ------------------------------
// 12Ô∏è‚É£ API th·ªëng k√™ doanh thu theo th·ªùi gian
// ------------------------------
exports.getRevenueStats = async (req, res) => {
    try {
        const { period = 'month' } = req.query; // period: 'day', 'week', 'month', 'year'
        const orders = await axios.get(Order_api);

        // L·ªçc c√°c ƒë∆°n h√†ng ƒë√£ ho√†n th√†nh
        const completedOrders = orders.data.filter(order => order.status === 'completed');

        // Nh√≥m doanh thu theo th·ªùi gian
        const revenueByPeriod = completedOrders.reduce((acc, order) => {
            const date = new Date(order.createdAt);
            let periodKey;

            switch (period) {
                case 'day':
                    periodKey = date.toISOString().split('T')[0];
                    break;
                case 'week':
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    periodKey = weekStart.toISOString().split('T')[0];
                    break;
                case 'month':
                    periodKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    break;
                case 'year':
                    periodKey = date.getFullYear().toString();
                    break;
                default:
                    periodKey = date.toISOString().split('T')[0];
            }

            acc[periodKey] = (acc[periodKey] || 0) + order.finalTotal;
            return acc;
        }, {});

        // T√≠nh to√°n c√°c ch·ªâ s·ªë
        const totalRevenue = Object.values(revenueByPeriod).reduce((sum, val) => sum + val, 0);
        const averageRevenue = Object.values(revenueByPeriod).length > 0
            ? totalRevenue / Object.values(revenueByPeriod).length
            : 0;

        res.json({
            revenueByPeriod,
            totalRevenue,
            averageRevenue,
            period
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ doanh thu",
            error: error.message
        });
    }
};

// ------------------------------
// 13Ô∏è‚É£ API th·ªëng k√™ s·∫£n ph·∫©m b√°n ch·∫°y
// ------------------------------
exports.getTopSellingProducts = async (req, res) => {
    try {
        const { limit = 10 } = req.query;
        const orders = await axios.get(Order_api);

        // T√≠nh to√°n s·ªë l∆∞·ª£ng b√°n c·ªßa t·ª´ng s·∫£n ph·∫©m
        const productSales = orders.data.reduce((acc, order) => {
            if (order.status === 'completed') {
                order.items.forEach(item => {
                    acc[item.productId] = (acc[item.productId] || 0) + item.quantity;
                });
            }
            return acc;
        }, {});

        // L·∫•y th√¥ng tin chi ti·∫øt s·∫£n ph·∫©m
        const products = await axios.get(PRODUCT_SERVICE_URL);
        const productDetails = products.data.data;

        // K·∫øt h·ª£p th√¥ng tin v√† s·∫Øp x·∫øp theo s·ªë l∆∞·ª£ng b√°n
        const topProducts = Object.entries(productSales)
            .map(([productId, quantity]) => {
                const product = productDetails.find(p => p._id === productId);
                return {
                    productId,
                    name: product?.name || 'Unknown Product',
                    category: product?.category || 'Unknown Category',
                    totalSold: quantity,
                    price: product?.price || 0,
                    revenue: (product?.price || 0) * quantity
                };
            })
            .sort((a, b) => b.totalSold - a.totalSold)
            .slice(0, parseInt(limit));

        res.json({
            topProducts,
            totalProducts: Object.keys(productSales).length
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ s·∫£n ph·∫©m b√°n ch·∫°y",
            error: error.message
        });
    }
};

// ------------------------------
// 14Ô∏è‚É£ API th·ªëng k√™ t·ªìn kho theo danh m·ª•c
// ------------------------------
exports.getInventoryByCategory = async (req, res) => {
    try {
        const products = await axios.get(PRODUCT_SERVICE_URL);
        const inventory = await Inventory.find({});

        // T·∫°o map ƒë·ªÉ d·ªÖ d√†ng truy xu·∫•t th√¥ng tin s·∫£n ph·∫©m
        const productMap = products.data.data.reduce((acc, product) => {
            acc[product._id] = product;
            return acc;
        }, {});

        // Th·ªëng k√™ t·ªìn kho theo danh m·ª•c
        const categoryStats = inventory.reduce((acc, item) => {
            const product = productMap[item.productId];
            if (product) {
                const category = product.category;
                if (!acc[category]) {
                    acc[category] = {
                        totalProducts: 0,
                        totalStock: 0,
                        lowStockCount: 0,
                        products: []
                    };
                }

                acc[category].totalProducts++;
                acc[category].totalStock += item.quantity;
                if (item.quantity <= LOW_STOCK_THRESHOLD) {
                    acc[category].lowStockCount++;
                }

                acc[category].products.push({
                    productId: item.productId,
                    name: item.name,
                    currentStock: item.quantity,
                    price: product.price,
                    totalValue: item.quantity * product.price
                });
            }
            return acc;
        }, {});

        // T√≠nh to√°n t·ªïng gi√° tr·ªã t·ªìn kho
        const totalInventoryValue = Object.values(categoryStats).reduce(
            (sum, category) => sum + category.products.reduce(
                (catSum, product) => catSum + product.totalValue, 0
            ), 0
        );

        res.json({
            categoryStats,
            totalInventoryValue,
            totalCategories: Object.keys(categoryStats).length
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ t·ªìn kho theo danh m·ª•c",
            error: error.message
        });
    }
};

// ------------------------------
// 15Ô∏è‚É£ API th·ªëng k√™ chi ti·∫øt ƒë∆°n h√†ng theo tr·∫°ng th√°i
// ------------------------------
exports.getOrderStatusStats = async (req, res) => {
    try {
        const orders = await axios.get(Order_api);

        // Th·ªëng k√™ theo tr·∫°ng th√°i
        const statusStats = orders.data.reduce((acc, order) => {
            acc[order.status] = (acc[order.status] || 0) + 1;
            return acc;
        }, {});

        // Th·ªëng k√™ doanh thu theo tr·∫°ng th√°i
        const revenueByStatus = orders.data.reduce((acc, order) => {
            acc[order.status] = (acc[order.status] || 0) + order.finalTotal;
            return acc;
        }, {});

        // Th·ªëng k√™ theo th·ªùi gian (24h g·∫ßn nh·∫•t, 7 ng√†y, 30 ng√†y)
        const now = new Date();
        const last24h = new Date(now - 24 * 60 * 60 * 1000);
        const last7days = new Date(now - 7 * 24 * 60 * 60 * 1000);
        const last30days = new Date(now - 30 * 24 * 60 * 60 * 1000);

        const timeStats = {
            last24h: orders.data.filter(order => new Date(order.createdAt) > last24h).length,
            last7days: orders.data.filter(order => new Date(order.createdAt) > last7days).length,
            last30days: orders.data.filter(order => new Date(order.createdAt) > last30days).length
        };

        res.json({
            statusStats,
            revenueByStatus,
            timeStats,
            totalOrders: orders.data.length
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ tr·∫°ng th√°i ƒë∆°n h√†ng",
            error: error.message
        });
    }
};

// ------------------------------
// 16Ô∏è‚É£ API th·ªëng k√™ doanh thu chi ti·∫øt theo s·∫£n ph·∫©m
// ------------------------------
exports.getProductRevenueStats = async (req, res) => {
    try {
        const orders = await axios.get(Order_api);
        const products = await axios.get(PRODUCT_SERVICE_URL);

        // T·∫°o map s·∫£n ph·∫©m ƒë·ªÉ d·ªÖ truy xu·∫•t
        const productMap = products.data.data.reduce((acc, product) => {
            acc[product._id] = product;
            return acc;
        }, {});

        // T√≠nh to√°n doanh thu v√† s·ªë l∆∞·ª£ng b√°n cho t·ª´ng s·∫£n ph·∫©m
        const productStats = orders.data.reduce((acc, order) => {
            if (order.status === 'completed') {
                order.items.forEach(item => {
                    if (!acc[item.productId]) {
                        acc[item.productId] = {
                            productId: item.productId,
                            name: productMap[item.productId]?.name || 'Unknown',
                            category: productMap[item.productId]?.category || 'Unknown',
                            totalSold: 0,
                            totalRevenue: 0,
                            averagePrice: 0,
                            orders: 0
                        };
                    }

                    acc[item.productId].totalSold += item.quantity;
                    acc[item.productId].totalRevenue += item.price * item.quantity;
                    acc[item.productId].orders += 1;
                });
            }
            return acc;
        }, {});

        // T√≠nh gi√° trung b√¨nh v√† s·∫Øp x·∫øp theo doanh thu
        const productStatsArray = Object.values(productStats).map(stat => ({
            ...stat,
            averagePrice: stat.totalSold > 0 ? stat.totalRevenue / stat.totalSold : 0
        })).sort((a, b) => b.totalRevenue - a.totalRevenue);

        // Th·ªëng k√™ theo danh m·ª•c
        const categoryStats = productStatsArray.reduce((acc, product) => {
            if (!acc[product.category]) {
                acc[product.category] = {
                    totalRevenue: 0,
                    totalSold: 0,
                    productCount: 0
                };
            }
            acc[product.category].totalRevenue += product.totalRevenue;
            acc[product.category].totalSold += product.totalSold;
            acc[product.category].productCount += 1;
            return acc;
        }, {});

        res.json({
            productStats: productStatsArray,
            categoryStats,
            totalRevenue: productStatsArray.reduce((sum, p) => sum + p.totalRevenue, 0),
            totalProducts: productStatsArray.length
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ doanh thu s·∫£n ph·∫©m",
            error: error.message
        });
    }
};

// ------------------------------
// 17Ô∏è‚É£ API th·ªëng k√™ t·ªïng h·ª£p chi ti·∫øt
// ------------------------------
exports.getDetailedStats = async (req, res) => {
    try {
        const [orders, products, inventory] = await Promise.all([
            axios.get(Order_api),
            axios.get(PRODUCT_SERVICE_URL),
            Inventory.find({})
        ]);

        // Th·ªëng k√™ ƒë∆°n h√†ng
        const orderStats = {
            total: orders.data.length,
            byStatus: orders.data.reduce((acc, order) => {
                acc[order.status] = (acc[order.status] || 0) + 1;
                return acc;
            }, {}),
            revenue: orders.data.reduce((sum, order) => sum + order.finalTotal, 0),
            averageOrderValue: orders.data.length > 0
                ? orders.data.reduce((sum, order) => sum + order.finalTotal, 0) / orders.data.length
                : 0
        };

        // Th·ªëng k√™ s·∫£n ph·∫©m
        const productStats = {
            total: products.data.data.length,
            byCategory: products.data.data.reduce((acc, product) => {
                acc[product.category] = (acc[product.category] || 0) + 1;
                return acc;
            }, {}),
            lowStock: inventory.filter(item => item.quantity <= LOW_STOCK_THRESHOLD).length,
            outOfStock: inventory.filter(item => item.quantity === 0).length
        };

        // Th·ªëng k√™ doanh thu theo th·ªùi gian
        const now = new Date();
        const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);

        const revenueStats = {
            total: orderStats.revenue,
            thisMonth: orders.data
                .filter(order => new Date(order.createdAt) >= thisMonth)
                .reduce((sum, order) => sum + order.finalTotal, 0),
            lastMonth: orders.data
                .filter(order => new Date(order.createdAt) >= lastMonth && new Date(order.createdAt) < thisMonth)
                .reduce((sum, order) => sum + order.finalTotal, 0)
        };

        // Th·ªëng k√™ t·ªìn kho
        const inventoryStats = {
            totalItems: inventory.reduce((sum, item) => sum + item.quantity, 0),
            totalValue: inventory.reduce((sum, item) => {
                const product = products.data.data.find(p => p._id === item.productId);
                return sum + (item.quantity * (product?.price || 0));
            }, 0),
            lowStockItems: inventory.filter(item => item.quantity <= LOW_STOCK_THRESHOLD)
                .map(item => ({
                    productId: item.productId,
                    name: item.name,
                    currentStock: item.quantity
                }))
        };

        res.json({
            orderStats,
            productStats,
            revenueStats,
            inventoryStats,
            lastUpdated: new Date()
        });
    } catch (error) {
        res.status(500).json({
            message: "L·ªói khi l·∫•y th·ªëng k√™ chi ti·∫øt",
            error: error.message
        });
    }
};
